package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"os"
	"os/exec"
	"sort"
	"strconv"
	"strings"

	"github.com/Azure/aztfy/internal"
	"github.com/Azure/aztfy/internal/config"
	"github.com/Azure/aztfy/internal/ui"
	azlog "github.com/Azure/azure-sdk-for-go/sdk/azcore/log"
	"github.com/urfave/cli/v2"
)

func main() {
	var (
		flagBatchMode      bool
		flagSubscriptionId string
		flagOutputDir      string
		flagMappingFile    string
		flagContinue       bool
		flagPattern        string
		flagOverwrite      bool
		flagAppend         bool
		flagBackendType    string
		flagBackendConfig  cli.StringSlice

		// hidden flags
		hflagLogPath    string
		hflagMockClient bool
	)
	app := &cli.App{
		Name:      "aztfy",
		Version:   getVersion(),
		Usage:     "Bring existing Azure resources under Terraform's management",
		UsageText: "aztfy [option] <resource group name>",
		Flags: []cli.Flag{
			&cli.BoolFlag{
				Name:        "batch",
				EnvVars:     []string{"AZTFY_BATCH"},
				Aliases:     []string{"b"},
				Usage:       "Batch mode (i.e. Non-interactive mode)",
				Destination: &flagBatchMode,
			},
			&cli.StringFlag{
				Name: "subscription-id",
				// Honor the "ARM_SUBSCRIPTION_ID" as is used by the AzureRM provider, for easier use.
				EnvVars:     []string{"AZTFY_SUBSCRIPTION_ID", "ARM_SUBSCRIPTION_ID"},
				Aliases:     []string{"s"},
				Usage:       "The subscription id",
				Destination: &flagSubscriptionId,
			},
			&cli.StringFlag{
				Name:    "output-dir",
				EnvVars: []string{"AZTFY_OUTPUT_DIR"},
				Aliases: []string{"o"},
				Usage:   "The output directory",
				Value: func() string {
					dir, _ := os.Getwd()
					return dir
				}(),
				Destination: &flagOutputDir,
			},
			&cli.StringFlag{
				Name:        "resource-mapping",
				EnvVars:     []string{"AZTFY_RESOURCE_MAPPING"},
				Aliases:     []string{"m"},
				Usage:       "The resource mapping file",
				Destination: &flagMappingFile,
			},
			&cli.BoolFlag{
				Name:        "continue",
				EnvVars:     []string{"AZTFY_CONTINUE"},
				Aliases:     []string{"k"},
				Usage:       "Whether continue on import error (batch mode only)",
				Destination: &flagContinue,
			},
			&cli.StringFlag{
				Name:        "name-pattern",
				EnvVars:     []string{"AZTFY_NAME_PATTERN"},
				Aliases:     []string{"p"},
				Usage:       `The pattern of the resource name. The resource name is generated by taking the pattern and adding an auto-incremental integer to the end. If pattern includes a "*", the auto-incremental integer replaces the last "*"`,
				Value:       "res-",
				Destination: &flagPattern,
			},
			&cli.BoolFlag{
				Name:        "overwrite",
				EnvVars:     []string{"AZTFY_OVERWRITE"},
				Aliases:     []string{"f"},
				Usage:       "Whether to overwrite the output directory if it is not empty (use with caution)",
				Destination: &flagOverwrite,
			},
			&cli.BoolFlag{
				Name:        "append",
				EnvVars:     []string{"AZTFY_APPEND"},
				Usage:       "Skip cleaning up the output directory prior to importing, everything will be imported to the existing state file if any (local backend only)",
				Destination: &flagAppend,
			},
			&cli.StringFlag{
				Name:        "backend-type",
				EnvVars:     []string{"AZTFY_BACKEND_TYPE"},
				Usage:       "The Terraform backend used to store the state",
				Value:       "local",
				Destination: &flagBackendType,
			},
			&cli.StringSliceFlag{
				Name:        "backend-config",
				EnvVars:     []string{"AZTFY_BACKEND_CONFIG"},
				Usage:       "The Terraform backend config",
				Destination: &flagBackendConfig,
			},

			// Hidden flags
			&cli.StringFlag{
				Name:        "log-path",
				EnvVars:     []string{"AZTFY_LOG_PATH"},
				Usage:       "The path to store the log",
				Hidden:      true,
				Destination: &hflagLogPath,
			},

			&cli.BoolFlag{
				Name:        "mock-client",
				EnvVars:     []string{"AZTFY_MOCK_CLIENT"},
				Usage:       "Whether to mock the client. This is for testing UI",
				Hidden:      true,
				Destination: &hflagMockClient,
			},
		},
		Action: func(c *cli.Context) error {
			if c.NArg() == 0 {
				return fmt.Errorf("No resource group specified")
			}
			if c.NArg() > 1 {
				return fmt.Errorf("More than one resource groups specified")
			}
			if flagBatchMode && flagMappingFile == "" {
				fmt.Println("[WARN]: No resource mapping file specified! Only the recognized resources will be imported.")
			}
			if flagContinue && !flagBatchMode {
				return fmt.Errorf("`--continue` must be used together with `--batch`")
			}
			if flagAppend {
				if flagBackendType != "local" {
					return fmt.Errorf("`--append` only works for local backend")
				}
				if flagOverwrite {
					return fmt.Errorf("`--append` conflicts with `--overwrite`")
				}
			}

			rg := c.Args().First()

			// Initialize the config
			cfg := config.Config{
				LogPath:    hflagLogPath,
				MockClient: hflagMockClient,
			}

			// The subscription id comes from one of following (starts from the highest priority):
			// - Command line option
			// - Env variable: AZTFY_SUBSCRIPTION_ID
			// - Env variable: ARM_SUBSCRIPTION_ID
			// - Output of azure cli, the current active subscription
			cfg.SubscriptionId = flagSubscriptionId
			if cfg.SubscriptionId == "" {
				var stderr bytes.Buffer
				var stdout bytes.Buffer
				cmd := exec.Command("az", "account", "show", "--query", "id")
				cmd.Stderr = &stderr
				cmd.Stdout = &stdout
				if err := cmd.Run(); err != nil {
					err = fmt.Errorf("failed to run azure cli: %v", err)
					if stdErrStr := stderr.String(); stdErrStr != "" {
						err = fmt.Errorf("%s: %s", err, strings.TrimSpace(stdErrStr))
					}
					return err
				}
				if stdout.String() == "" {
					return fmt.Errorf("subscription id is not specified")
				}
				var err error
				cfg.SubscriptionId, err = strconv.Unquote(strings.TrimSpace(stdout.String()))
				if err != nil {
					return fmt.Errorf("unquoting %s: %v", stdout.String(), err)
				}
			}

			if flagMappingFile != "" {
				b, err := os.ReadFile(flagMappingFile)
				if err != nil {
					return fmt.Errorf("reading mapping file %s: %v", flagMappingFile, err)
				}
				if err := json.Unmarshal(b, &cfg.ResourceMapping); err != nil {
					return fmt.Errorf("unmarshalling the mapping file: %v", err)
				}
			}

			cfg.ResourceGroupName = rg
			cfg.OutputDir = flagOutputDir
			cfg.ResourceNamePattern = flagPattern
			cfg.Overwrite = flagOverwrite
			cfg.Append = flagAppend
			cfg.BatchMode = flagBatchMode
			cfg.BackendType = flagBackendType
			cfg.BackendConfig = flagBackendConfig.Value()

			// Initialize logger
			log.SetOutput(io.Discard)
			if cfg.LogPath != "" {
				log.SetPrefix("[aztfy] ")
				f, err := os.OpenFile(cfg.LogPath, os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0644)
				if err != nil {
					return fmt.Errorf("creating log file %s: %v", cfg.LogPath, err)
				}
				log.SetOutput(f)

				// Enable the logging for the Azure SDK
				os.Setenv("AZURE_SDK_GO_LOGGING", "all")
				azlog.SetListener(func(cls azlog.Event, msg string) {
					log.Printf("[SDK] %s: %s\n", cls, msg)
				})
			}

			// Run in batch mode
			if cfg.BatchMode {
				if err := internal.BatchImport(cfg, flagContinue); err != nil {
					return err
				}
				return nil
			}

			// Run in interactive mode
			prog, err := ui.NewProgram(cfg)
			if err != nil {
				return err
			}
			if err := prog.Start(); err != nil {
				return err
			}
			return nil
		},
	}

	sort.Sort(cli.FlagsByName(app.Flags))

	if err := app.Run(os.Args); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v", err)
		os.Exit(1)
	}
}
